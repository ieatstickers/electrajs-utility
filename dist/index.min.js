!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r=t();for(var o in r)("object"==typeof exports?exports:e)[o]=r[o]}}(self,(()=>(()=>{"use strict";var e,t={d:(e,r)=>{for(var o in r)t.o(r,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};t.r(r),t.d(r,{Arrays:()=>a,HydrateModeEnum:()=>e,Numbers:()=>o,Objects:()=>n,Promises:()=>i,Strings:()=>c});class o{static random(e,t){if(e>t)throw new Error("Minimum value cannot be greater than maximum value");return Math.floor(Math.random()*(t-e+1))+e}}!function(e){e.SOURCE_PROPERTIES="source_properties",e.DEST_PROPERTIES="dest_properties"}(e||(e={}));class n{static clone(t){if(!t||"object"!=typeof t||Array.isArray(t))throw new TypeError("Cannot clone object. Source object must be of type 'object'.");return this.hydrate(Object.create(t),t,{mode:e.SOURCE_PROPERTIES,includeNullValues:!0,includeMethods:!0})}static hydrate(t,r,o){if(o&&("object"!=typeof o||Array.isArray(o)))throw new TypeError('Cannot hydrate object. Options must be of type "object"');if(o=Object.assign({mode:e.DEST_PROPERTIES,mutators:{},includeNullValues:!0,includeMethods:!1},o||{}),!r||!t||"object"!=typeof t||"object"!=typeof r||Array.isArray(t)||Array.isArray(r))throw new TypeError('Cannot hydrate object. Source and destination object must both be of type "object"');const n=o.mode===e.SOURCE_PROPERTIES?Object.keys(r):Object.keys(t);for(const e of n){if(!r.hasOwnProperty(e))continue;const n=r[e];if(!1!==o.includeMethods||"function"!=typeof n)if(o.mutators[e]){if("function"!=typeof o.mutators[e])throw new Error(`Cannot hydrate object. Mutator for property "${e}" is not a function`);t[e]=o.mutators[e](n)}else!0===o.includeNullValues&&null==n?t[e]=n:Array.isArray(n)?t[e]=a.clone(n):t[e]="object"==typeof n?this.clone(n):n}return t}static getByKeyPath(e,t,r){if(!Array.isArray(e)||0===e.length)throw new TypeError("Invalid key path. Must be an array of strings and/or numbers.");const o=e.slice();let n=t;for(;o.length>0;){const e=o.shift();if(!n||"object"!=typeof n||!n.hasOwnProperty(e))return r;n=n[e]}return n}static setByKeyPath(e,t,r){if(!Array.isArray(e)||0===e.length)throw new TypeError("Invalid key path. Must be an array of strings and/or numbers.");const o=e.slice(),n=o.shift();return o.length?r[n]=this.setByKeyPath(o,t,r[n]||{}):r[n]=t,r}}class a{static clone(e){if(!Array.isArray(e))throw new TypeError(`Input type "${typeof e}" passed to Arrays.clone()`);return e.map((e=>Array.isArray(e)?this.clone(e):"object"==typeof e?n.clone(e):e))}static randomItem(e){if(!Array.isArray(e))throw new TypeError(`Input type "${typeof e}" passed to Arrays.randomItem()`);if(0===e.length)throw new Error("Cannot get random item from empty array");return e[o.random(0,e.length-1)]}}var s=function(e,t,r,o){return new(r||(r=Promise))((function(n,a){function s(e){try{c(o.next(e))}catch(e){a(e)}}function i(e){try{c(o.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?n(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(s,i)}c((o=o.apply(e,t||[])).next())}))};class i{static all(e){return s(this,void 0,void 0,(function*(){if(!e||"object"!=typeof e||Array.isArray(e))throw new TypeError('Cannot resolve promises. Input must be of type "object"');if(Object.values(e).some((e=>!(e instanceof Promise))))throw new TypeError('Cannot resolve promises. Input must be of type "object" with all values being of type "Promise"');return Object.fromEntries(yield Promise.all(Object.entries(e).map((([e,t])=>s(this,void 0,void 0,(function*(){return[e,yield t]}))))))}))}}class c{static initialCaps(e){const t=e.split(" ");return t.reduce(((e,r,o)=>(e+=r.charAt(0).toUpperCase()+r.slice(1),o<t.length-1&&(e+=" "),e)),"")}static random(e=10,t){let r,o=0;for(;!r||t&&t.length&&t.includes(r);)if(r=this.generateRandomString(e,this.URL_SAFE_CHARS),o++,o>=100)throw new Error(`Could not generate a random string that isn't blacklisted after ${o} attempts`);return r}static generateRandomString(e,t){let r="";for(let n=0;n<e;n++)r+=t.charAt(o.random(0,t.length-1));return r}}return c.URL_SAFE_CHARS="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._",r})()));